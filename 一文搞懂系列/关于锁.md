# 一文搞懂计算机锁

## 锁的定义

在计算机科学中，锁(lock)是一种同步机制，用于控制多个线程或进程对共享资源的访问，以防止并发访问导致的数据竞争和不一致性。锁是一种数据结构或标记，用于表示资源的占用状态。它可以是互斥锁（Mutex）、信号量（Semaphore）、读写锁（Read-Write Lock）等不同类型。 锁具有两个主要操作：锁定（Lock）和解锁（Unlock）。线程或进程在访问资源之前必须获得锁，然后在完成后释放锁。 

## **锁的作用**

防止并发访问：锁可以确保在同一时刻只有一个线程或进程可以进入临界区（对共享资源的访问区域），从而防止多个线程同时修改资源，避免数据竞争。 维护数据一致性：通过锁定共享资源，可以确保对资源的修改按照正确的顺序执行，从而维护数据的一致性。 确保互斥性：锁可以用于实现互斥，即某一时刻只有一个线程可以执行临界区代码，其他线程需要等待。 不同类型的锁有不同的特性和用途。例如，互斥锁通常用于保护对共享资源的独占访问，而读写锁允许多个线程同时读取共享资源，但在写入时需要互斥。锁的正确使用对于多线程和多进程编程至关重要，因为它有助于避免常见的并发问题，如死锁、竞争条件和数据不一致性。

## 锁的分类

**互斥锁与共享锁**：

互斥锁：顾名思义，就是互斥的，意思就是当前同步代码块只能被一个线程访问，sync、reentrantlock、writelock都是互斥锁

共享锁：与互斥锁相反，就是当前同步代码块可以被多个线程同时访问。目前只知道Readlock，通过condition实现了共享锁。

**公平锁与非公平锁**

 公平锁：就是在获取锁的时候，哪个线程等的时间长就优先调用哪个线程，reentrantlock可实现公平锁，通过队列来实现控制。

非公平锁：就是随机的了，所以吞吐量比公平锁高。sync锁默认非公平锁，不可修改，reentrantlock默认非公平锁，可修改为公平锁

**可重入锁–不可重入锁**

 可重入锁：当前线程已经持有锁，在同步代码块中调用其他的锁的方法（锁的对象是同一个）时，可以无条件进入。可重入锁的优点就是，可以避免死锁 举个例子：A和B两个方法，锁的对象都是同一个，在A方法同步代码中调用B方法，可以进入B方法执行，称为可重入锁。可以看一下ReentrantLock中的实现。

不可重入锁：就是不能进入。也是可以通过ReentrantLock锁中重写AQS中的tryAcquire方法：当判断锁状态不为0时，则直接返回，省略判断与持有锁的线程是否相等这一步，即可得到非重入锁

**乐观锁–悲观锁**

在获取的时候，不上锁，但是在set的时候，通过某种方式的操作,保证了数据的正确性，乐观锁的乐观所体现的地方就是，在get的时候不上锁，认为在我操作期间，不会有其他线程对数据进行操作。但是又不得不防止会出现有其他线程干扰的操作，最常见的就是CAS算法实现数据正确性，最常见的例子就是在数据库中设计版本号字段，通过对他进行操作，实现CAS算法。

悲观锁，那就是在乐观锁体现乐观的地方的相反，就是在获取的时候，就上锁，这个就不用多说了。

**死锁–活锁–饥饿**

是程序上由于设计错误或者不合理导致的，其中一种情况就是T1线程得到A资源，但是又必须获取B资源才能继续业务操作，此时T2线程得到了B资源，也是必须要获取到A资源才能继续业务操作，这种你咬我、我咬着你，但又都不释放锁的情况称为死锁。
死锁可以概括为，就是某个线程在同步代码块中，获取不到相关资源，导致进行不下去，但又释放不了的情况。预防死锁：一次上锁、顺序上锁。

活锁：是当T1线程获取锁，T2线程过来，那么T1将锁让给T2，然后T3线程过来，T2又让给T3，这样互相让，就是活锁。预防：先来先服务。

饥饿：我们知道线程有优先级的设置，如果此时T1线程获取锁，T2线程来了并且优先级高于T1，此时T2处理完后，本该交给T1，但是此时又来了T3，同样T3的线程优先级高于T1，T4…这样的情况，T1被称为饥饿。

**读写锁**

读锁是共享锁，写锁是互斥锁（排他锁），读读不互斥、读写互斥、写写互斥
**自旋锁** 

获取到锁之前不会进入阻塞，不会释放时间片，而是在那自旋，直到获取锁。
**偏向锁** 

偏向锁就是偏心的偏。也是对sync锁进行的优化，

**轻量级锁–重量级锁**

轻量级锁：就是线程不用阻塞，通过cas进行自旋获取锁。其实轻量级锁表示的意思就是现在这个锁已经存在了竞争。 

重量级锁：当线程获取不到锁时，进入阻塞状态，因为涉及到线程上下的切换（就是用户态切换成内核态），而这很消耗性能，所以才被称为“重量级锁”。




## 自旋锁

### 自旋锁的提出背景

由于在多处理器环境中某些资源的有限性，有时需要互斥访问(mutual exclusion)，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取到锁。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？

通常有两种处理方式：一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做`互斥锁`。

### 什么是自旋锁

自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为`自旋锁(spinlock)`。

![file](https://img2018.cnblogs.com/blog/1515111/201910/1515111-20191015194619321-127153615.jpg)

### 自旋锁的原理

自旋锁的原理比较简单，如果持有锁的线程能在短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，它们只需要等一等(自旋)，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗。

因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，**操作系统的内核经常使用自旋锁**。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 `OS(Operating System)` 调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不打算释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。

解决上面这种情况一个很好的方式是给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁。自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。但是如何去选择自旋时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！JDK在1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋时间不是固定的了，而是由前一次在同一个锁上的自旋时间以及锁拥有的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。

### 自旋锁的优缺点

自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！

但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。

### 如何分辨使用何种自旋锁

​		如果被保护的共享资源只在进程上下文访问**和**软中断（包括tasklet、timer）上下文访问，那么当在进程上下文访问共享资源时，可能被软中断打断，从而可能进入软中断上下文来对被保护的共享资源访问，因此对于这种情况，对共享资源的访问必须使用spin_lock_bh和spin_unlock_bh来保护。

注：就是正常在进程中访问共享资源时，可能被软件中断给打断。软中断需要访问共享资源，此时就会出现抢占资源的情况，对于这种情况，对共享资源的访问就必须使用spin_lock_bh和spin_unlock_bh来保护。

​		如果被保护的共享资源只在两个或多个tasklet**或**timer上下文访问，那么对共享资源的访问仅需要用spin_lock和spin_unlock来保护，不必使用_bh版本，因为当tasklet或timer运行时，不可能有其他tasklet或timer在当前CPU上运行。

​		如果被保护的共享资源只在一个tasklet或timer上下文访问，那么不需要任何自旋锁保护，因为同一个tasklet或timer只能在一个CPU上运行，即使是在SMP环境下也是如此。实际上tasklet在调用tasklet_schedule标记其需要被调度时已经把该tasklet绑定到当前CPU，因此同一个tasklet决不可能同时在其他CPU上运行。timer也是在其被使用add_timer添加到timer队列中时已经被绑定到当前CPU，所以同一个timer绝不可能运行在其他CPU上。当然同一个tasklet有两个实例同时运行在同一个CPU就更不可能了

​		如果被保护的共享资源只在一个软中断（tasklet和timer除外,例如workqueue工作队列可以在不同cpu上运行）上下文访问，那么这个共享资源需要用spin_lock和spin_unlock来保护，因为同样的软中断可以同时在不同的CPU上运行

​		如果被保护的共享资源在两个或多个软中断上下文访问，那么这个共享资源当然更需要用spin_lock和spin_unlock来保护，不同的软中断能够同时在不同的CPU上运行。

​		如果被保护的共享资源在软中断（包括tasklet和timer）或进程上下文和硬中断上下文访问，那么在软中断或进程上下文访问期间，可能被硬中断打断，从而进入硬中断上下文对共享资源进行访问，因此，在进程或软中断上下文需要使用spin_lock_irq和spin_unlock_irq来保护对共享资源的访问。

​		而在中断处理句柄中使用什么版本，需依情况而定，如果只有一个中断处理句柄访问该共享资源，那么在中断处理句柄中仅需要spin_lock和spin_unlock来保护对共享资源的访问就可以了。因为在执行中断处理句柄期间，不可能被同一CPU上的软中断或进程打断。

但是如果有不同的中断处理句柄访问该共享资源，那么需要在中断处理句柄中使用spin_lock_irq和spin_unlock_irq来保护对共享资源的访问。

​		在使用spin_lock_irq和spin_unlock_irq的情况下，完全可以用spin_lock_irqsave和spin_unlock_irqrestore取代，那具体应该使用哪一个也需要依情况而定，如果可以确信在对共享资源访问前中断是使能的，那么使用spin_lock_irq更好一些。因为它比spin_lock_irqsave要快一些，但是如果你不能确定是否中断使能，那么使用spin_lock_irqsave和spin_unlock_irqrestore更好，因为它将恢复访问共享资源前的中断标志而不是直接使能中断。

​		当然，有些情况下需要在访问共享资源时必须中断失效，而访问完后必须中断使能，这样的情形使用spin_lock_irq和spin_unlock_irq最好。

​		spin_lock用于阻止在不同CPU上的执行单元对共享资源的同时访问以及不同进程上下文互相抢占导致的对共享资源的非同步访问，而中断失效和软中断失效却是为了阻止在同一CPU上软中断或中断对共享资源的非同步访问。

#### 各种上下文

- 进程上下文（Process Context）: 进程上下文是用户空间进程执行时的上下文环境。 当一个进程运行时，它在进程上下文中执行用户空间的代码，可以访问用户空间的内存。 进程上下文包括进程的寄存器状态、进程的地址空间信息等。 进程上下文中的代码通常与用户应用程序相关，执行各种用户任务，例如文件操作、网络通信等。

- 软中断上下文（Soft Interrupt Context）: 软中断上下文是内核内部的一种上下文，用于异步执行内核任务。 软中断是一种内核中的软件事件，通常用于执行延迟的或低优先级的工作。 与进程上下文不同，软中断上下文中执行的代码不依赖于特定的进程，并且不能访问用户空间的内存。 任务调度、定时器处理和网络中断处理等都可以在软中断上下文中执行。 

- 硬件中断上下文（Hardware Interrupt Context）: 硬件中断上下文是由硬件设备触发的中断时的上下文环境。 当硬件设备产生中断信号（例如，键盘输入或网络数据包到达），CPU会在硬件中断上下文中运行相应的中断处理程序。 硬件中断处理程序执行期间，内核会禁用其他中断，以确保不会被中断打断。 硬件中断上下文通常是紧急且时间敏感的，用于响应硬件事件

#### 自旋锁使用

```c
//1.分配自旋锁
spinlock_t lock;
//2.初始化自旋锁
spin_lock_init(&lock);
//3.访问临界区之前获取锁：
spin_lock(&lock);  //获取自旋锁，立即返回，如果没有获取锁，将进行忙等待
 或者
spin_trylock(&lock); //获取锁，返回true,否则返回false,所以这个函数一定要对返回值进行判断！
//4 .访问临界区
//5.释放自旋锁
spin_unlock(&lock);
```

#### 自旋锁的注意事项

1. 自旋锁使CPU处于忙等状态，因此临界区执行时间应该尽量短；
2. 自旋锁是不可重入的；
3. 自旋锁保护的临界区不应该有睡眠操作：
   1）对于开中断的自旋锁来说，睡眠操作可能发生如下两种情况：
   a. 死锁：任务A获得自旋锁之后睡眠，接着又发生了中断，而中断处理程序内部又打算获取同一个自旋锁，则此时会发生自死锁 —— 自旋锁是不可重入的。
   b. CPU浪费：倘若中断处理程序内部没有获取同一个自旋锁的操作，则理论上可以产生调度。假设进程B打算获取CPU的控制权，但由于此时是关抢占的（因为进程A还没有解自旋锁，此时依旧处于自旋锁的临界区中），导致进程B无法运行。也就是说CPU将无法运行任何程序，一直处于无事可做的状态，造成CPU的浪费。
   2）对于顺带关中断的自旋锁来说，显而易见在临界区内使不能睡眠的，因为唤醒一个睡眠的进程依赖于调度器，而调度器是通过时钟中断来判断合适唤醒进程的，倘若在关闭中断的时候进程睡眠，则调度器将再也无法收到时钟中断（因为开中断的操作也是由该进程控制的），从而永远都无法唤醒睡眠的进程。也就是说该进程将处于睡死状态。

简单来说，自旋锁的初衷就是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋(特别浪费处理器时间)，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。







